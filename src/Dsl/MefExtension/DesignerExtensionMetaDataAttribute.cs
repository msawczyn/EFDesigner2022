  
#pragma warning disable CS1591
// ReSharper disable RedundantNameQualifier
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using MEF = global::System.ComponentModel.Composition;
using Modeling = global::Microsoft.VisualStudio.Modeling;
using ModelingExtEnablement = global::Microsoft.VisualStudio.Modeling.ExtensionEnablement;
using DiagramsExtEnablement = global::Microsoft.VisualStudio.Modeling.Diagrams.ExtensionEnablement;

namespace Sawczyn.EFDesigner.EFModel.ExtensionEnablement
{
	/// <summary>
	/// Provides an extension filter string that can be used by all behavioural extension registrars generated for this designer.
	/// </summary>
	/// <remarks>For internal use within this Designer</remarks>
	internal sealed class EFModelExtensionFilter
	{
		internal const string MefMetadataFilter = "EFModelExtensionFilter";
	}

	/// <summary>
	/// Provides a strongly typed custom attribute which allows user to use the following: 
	///     [EFModelGestureExtension]
	/// in lieu of
	///		[Export(typeof(IGestureExtension)]
	///		[ExportMetadata("EFModelExtensionFilter", null)] 
	///
	/// Use this attribute to Export an IGestureExtension MEF part for EFModel designer.
	/// </summary>
	[MEF::MetadataAttribute]
	[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple=false)]
	public sealed class EFModelGestureExtensionAttribute : MEF::ExportAttribute
	{
		public EFModelGestureExtensionAttribute() : base(typeof(DiagramsExtEnablement.IGestureExtension))
		{
		}
		
		/// <summary>
		/// MEF metadata exported by this part.
		/// 
		/// The Property name is the key which indicates the base designer to which this extension belongs.
		/// </summary>
		public object EFModelExtensionFilter
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
	}
	
	/// <summary>
	/// Provides a strongly typed custom attribute which allows user to use the following: 
	///     [EFModelCommandExtension]
	/// in lieu of
	///		[Export(typeof(ICommandExtension)]
	///		[ExportMetadata("EFModelExtensionFilter", null)] 
	///
	/// Use this attribute to Export an ICommandExtension MEF part for EFModel designer.
	/// </summary>
	[MEF::MetadataAttribute]
	[global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple=false)]
	public sealed class EFModelCommandExtensionAttribute : MEF::ExportAttribute
	{
		public EFModelCommandExtensionAttribute() : base(typeof(ModelingExtEnablement.ICommandExtension))
		{
		}
		
		/// <summary>
		/// MEF metadata exported by this part.
		/// 
		/// The Property name is the key which indicates the base designer to which this extension belongs.
		/// </summary>
		public object EFModelExtensionFilter
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
	}
	
	/// <summary>
	/// Provides a strongly typed custom attribute which allows user to use the following: 
	///     [EFModelValidationExtension]
	/// in lieu of
	///		[Export(typeof(typeof(Action&lt;ValidationContext, object&gt;))]
	///		[ExportMetadata("EFModelExtensionFilter", null)]
	///
	/// Use this attribute to Export a ValidationExtension MEF part for EFModel designer.
	/// </summary>
	[MEF::MetadataAttribute]
	[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple=false)]
	public sealed class EFModelValidationExtensionAttribute : MEF::ExportAttribute
	{
		public EFModelValidationExtensionAttribute() : base(typeof(global::System.Action<Modeling::Validation.ValidationContext, object>))
		{
		}
		
		/// <summary>
		/// MEF metadata exported by this part.
		/// 
		/// The Property name is the key which indicates the base designer to which this extension belongs.
		/// </summary>
		public object EFModelExtensionFilter
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get { return null; }
		}
	}	
}